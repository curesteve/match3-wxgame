# 三消游戏迭代开发计划

## 目标平台：微信小游戏

**已确定**：本产品为**微信小游戏**，在微信内运行，需遵循小游戏规范与 API。

### 技术栈与运行环境

- **运行时**：微信小游戏运行环境（非完整浏览器，无 DOM/BOM）。
- **开发语言**：JavaScript 或 TypeScript（编译为 JS 后放入小游戏目录）。
- **渲染**：使用小游戏提供的 **Canvas 2D API**（通过 `wx.createCanvas()` 获取画布，API 与标准 Canvas 2D 兼容，有少量差异需适配）。
- **交互**：触摸事件 `wx.onTouchStart/End/Move`，坐标需按画布尺寸与设备像素比换算。
- **项目结构**：小游戏根目录需包含 `game.js`（入口）、`game.json`（小游戏配置，如设备方向、是否全屏等）；资源放在项目内或通过 `wx.downloadFile` 等加载。

### 与 Web 的差异（阶段内需注意）

| 方面    | Web                                 | 微信小游戏                                     |
| ----- | ----------------------------------- | ----------------------------------------- |
| 入口    | HTML + script                       | `game.js` 主入口，无 document/window           |
| 画布    | `document.getElementById('canvas')` | `wx.createCanvas()` 或 `canvas` 标签（适配层）    |
| 存储    | localStorage                        | `wx.getStorageSync` / `wx.setStorageSync` |
| 音频    | Audio / Howler.js                   | `wx.createInnerAudioContext()` 等          |
| 分包与包体 | 无硬性限制                               | 主包 4MB、分包 8MB 等限制，需注意资源体积                 |

### 开发与调试

- 使用**微信开发者工具**打开小游戏项目，真机预览与调试。
- 逻辑层与渲染层分离时，需注意小游戏的「离屏 Canvas」与主 Canvas 用法（阶段一若仅单 Canvas 则无需关心）。

以下各阶段在实现时均按**微信小游戏**环境编写与适配；阶段六（梦幻家园/花园式 meta）留待后续深入讨论。

---

## 阶段一：最小可玩核心（MVP）

**目标**：能玩起来的「交换 → 三连消除 → 下落填充」循环，无计分、无关卡。

1. **网格与数据**
  - 定义二维网格（如 8×8），每个格子存「类型/颜色」ID（如 1–5 代表 5 种宝石）。
  - 初始化时随机填充，确保**无初始三连**（生成后做一次检测，若有则重排或替换）。
2. **交互：选择与交换**
  - 点击/触摸格子 A 选中，再点格子 B：若 A、B 相邻（上下左右），执行一次**交换**。
  - 仅允许「相邻」交换，并限制为「每轮一次交换」的逻辑（即先不实现「交换无效则回退」也可，先保证能交换）。
3. **消除判定**
  - 交换后检测：横、竖方向是否有连续 ≥3 个相同类型。
  - 若**有**：标记这些格子为「待消除」→ 从网格移除 → 进入下落与填充。
  - 若**无**：可在此阶段简单实现「回退交换」，使两格恢复，避免无效操作。
4. **下落与填充**
  - **下落**：每列自上而下扫描，让「空位」上方的格子依次下落到底。
  - **填充**：列顶空位用随机类型（1–5）填充。
  - 填充后**再次做消除判定**：若仍有三连则继续消除 → 下落 → 填充，直到没有新的三连（即实现**连消/叠消**）。
5. **回合与输入**
  - 一轮内：完成「交换 → 可能多次消除与下落」直到稳定后，才允许下一次交换。
  - 用简单状态机：`idle`（可操作）→ `swapping` → `resolving`（消除+下落循环）→ `idle`。

**微信小游戏适配**：入口为 `game.js`，在 `game.js` 内获取画布（如 `wx.createCanvas()` 或使用小游戏模板中的 canvas），用 `wx.onTouchStart`/`wx.onTouchEnd` 处理点击并换算为格子坐标；无 `document`/`window`，不依赖 DOM。
**交付物**：在微信开发者工具与真机上可运行的小游戏，能持续「选两格交换 → 自动消除、下落、再消」的循环，无胜利/失败条件。

### 阶段一任务拆分（微信小游戏）

按实现顺序拆分为可执行任务，便于逐项完成与自测。

**推荐目录与入口**

- 小游戏根目录：`game.js`（入口）、`game.json`（小游戏配置）。
- 可选：`js/` 下放游戏逻辑（如 `js/grid.js`、`js/game.js`），由根目录 `game.js` 引用；或阶段一全部写在根目录 `game.js` 以简化。

| 序号   | 任务              | 说明                                                                                                                                                     | 验收                   |
| ---- | --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------- |
| 1.1  | 创建小游戏壳子         | 新建 `game.json`（`deviceOrientation: "portrait"` 等）、根目录 `game.js` 内仅 `console.log` 或空逻辑；用微信开发者工具打开，能正常启动并看到日志。                                           | 工具内运行无报错             |
| 1.2  | 创建画布并获取上下文      | 在 `game.js` 中调用 `wx.createCanvas()` 得到 canvas，再 `canvas.getContext('2d')` 得到 `ctx`；定义画布宽高常量（如 400×400 或按窗口适配），便于后续格子尺寸计算。                              | 能拿到 `ctx` 且可清屏绘制一帧   |
| 1.3  | 定义网格常量与数据结构     | 定义 `COLS=8`、`ROWS=8`、`GEM_TYPES=5`、`CELL_SIZE`（由画布宽高与行列数算出）；用二维数组 `grid[row][col]` 存格子类型（0～GEM_TYPES-1 为宝石，-1 表示空）。                                    | 数据结构与常量可在代码中直接使用     |
| 1.4  | 实现随机填充且无初始三连    | 写 `initGrid()`：先随机填满网格；再写 `getMatches()` 返回当前所有三连及以上格子坐标集合；若 `getMatches().length > 0` 则重新随机填充并重复直到无三连。                                                | 开局棋盘无任何三连            |
| 1.5  | 实现三连检测算法        | `getMatches()`：横向、纵向各扫描一遍，找出连续 ≥3 个相同类型（且非空）的格子，去重后返回 `[{row, col}, ...]`。                                                                             | 交换后能正确识别新产生的三连       |
| 1.6  | 实现交换与相邻判定       | 写 `swap(r1,c1, r2,c2)` 交换两格数据；写 `isAdjacent(r1,c1, r2,c2)` 判断是否上下或左右相邻。                                                                                | 仅相邻两格可交换             |
| 1.7  | 实现消除、下落、填充与连消循环 | 写 `removeMatches(matches)` 将匹配格置为 -1；`drop()` 每列自下而上把非空格子下落到底；`refill()` 把空位填随机类型。写 `resolveAll()`：循环执行「取匹配 → 若无则结束，若有则 remove → drop → refill」直到无新匹配。 | 一次交换后连消、叠消能自动跑完      |
| 1.8  | 实现状态机与回合控制      | 状态：`idle`（可操作）、`resolving`（消除中）。交换后若有匹配则进入 `resolving`，在 `resolveAll` 的每一帧或结束时检查是否还有匹配，没有则回到 `idle`。仅在 `idle` 时响应触摸选择/交换。                              | 消除过程中无法再次点击交换        |
| 1.9  | 绑定触摸并换算格子坐标     | 使用 `wx.onTouchStart`（或 `canvas.onTouchStart`，视小游戏版本）拿到触摸点；用画布在屏幕上的位置与缩放，将触摸坐标换算为画布内坐标，再除以 `CELL_SIZE` 得到 `col`、`row`；边界判断，得到合法格子。                      | 点击能正确对应到格子 (row,col) |
| 1.10 | 实现选择与交换的点击逻辑    | 第一次点击：记录 `selected = {row, col}` 并重绘；第二次点击：若同格则清空选中；若相邻则执行 `swap`，若有匹配则调用 `resolveAll()`，若无匹配则再 `swap` 回退；最后清空 `selected`。                             | 选两格相邻即交换，无效交换会回退     |
| 1.11 | 绘制网格与选中态        | 每帧或状态变化时：遍历 `grid`，对非空格子按类型用不同颜色绘制（圆角矩形或圆形），选中格加白边或高亮；空位可留空或浅色底。使用 `ctx` 的 `fillStyle`、`fillRect`/`roundRect` 等，不依赖 DOM。                               | 棋盘与选中态在工具和真机上显示正确    |
| 1.12 | 触发重绘与真机自测       | 在 `idle` 与 `resolving` 的每次状态/数据变化后调用一次绘制；`resolveAll` 中可用 `requestAnimationFrame` 或定时器分步执行消除与下落以便观察（或先做即时完成版）。在微信开发者工具与真机预览中各玩几轮，确认无报错、触摸顺滑、连消正确。      | 工具与真机均可玩、无崩溃         |

**依赖关系简述**：1.1 → 1.2 → 1.3 → 1.4（依赖 1.5 的 getMatches）→ 1.5 → 1.6 → 1.7（依赖 1.5）→ 1.8 → 1.9 → 1.10 → 1.11 → 1.12。建议先做 1.5 再完善 1.4，或 1.4 中先写简单版 getMatches 再在 1.5 中补全。

---

## 阶段二：计分与回合限制

**目标**：有分数、有「步数」限制，形成基本关卡目标。

1. **计分规则**
  - 单次消除：每格 N 分（如 10），三连=30，四连=40，五连=50；可再乘以连消序号（第一次×1，第二次×2）做**连消加成**。
  - 在消除时累加分数，并在 UI 显示当前关分数。
2. **步数（移动次数）**
  - 每关固定步数（如 20 步），每执行一次「交换」扣 1 步（不论是否产生消除）。
  - 步数用尽后进入「失败」：显示失败 UI，提供重试。
3. **关卡数据结构**
  - 用 JSON/配置定义关卡：网格大小、步数、目标分数（可选）、初始棋盘（可选，否则全随机）。
  - 实现「当前关卡 ID + 加载该关卡配置」的流程。
4. **胜利/失败条件**
  - **胜利**：步数内达到目标分数；或仅「步数内存活」也可作为第一版简单目标。
  - **失败**：步数用尽且未达目标。
  - 胜利后：简单「下一关」按钮，加载下一关配置并重置步数/分数。

**交付物**：多关卡、每关有步数与目标分数，能判定过关/不过关并进入下一关。

### 阶段二任务拆分（微信小游戏）

按实现顺序拆分为可执行任务，与当前 game.js 的关卡配置、网格与胜负判定衔接。

| 序号 | 任务 | 说明 | 验收 |
|------|------|------|------|
| **2.1** | 定义关卡配置结构与加载方式 | 新建 levels.js 或内联常量，每关一条配置：`{ id, moves, targetScore, grid? }`（grid 可选，缺省则随机生成）。提供 `getLevelConfig(levelId)` 返回该关配置。 | 能根据关卡 ID 取到步数、目标分、可选初始盘面 |
| **2.2** | 引入关卡状态与重置逻辑 | 在 game.js 中增加：`currentLevelId`、`movesLeft`、`score`。写 `startLevel(levelId)`：加载配置、置 movesLeft/score、若配置有 grid 则用其初始化否则 `initGrid()`（并保证无三连），最后 `render()`。 | 调用 startLevel(n) 后棋盘与步数/分数符合该关配置 |
| **2.3** | 实现计分规则并在消除时累加 | 在消除阶段（如 removeMatches 调用处或消除动画结束处）按本次消除格子数计分（如每格 10，三连=30、四连=40、五连=50）；可选连消加成（第 1 次×1、第 2 次×2…）。累加到 `score`。 | 消除后 score 正确增加，连消有加成则符合规则 |
| **2.4** | 步数扣减与交换入口统一 | 在唯一执行「交换」的地方（当前为 onTouchEnd 里在 swap 之后）：先扣 `movesLeft--`，再执行原有 swap 与 match 逻辑。若 `movesLeft <= 0` 则不再允许交换并进入失败流程。 | 每有效交换一次扣 1 步，步数用尽后无法再换 |
| **2.5** | 胜利判定与「下一关」 | 在每轮消除稳定后（如 state 回到 idle 时）：若 `score >= targetScore` 则胜利。胜利后：显示简单胜利 UI（文案 + 按钮），点击「下一关」调用 `startLevel(currentLevelId + 1)` 并关闭胜利 UI。 | 达到目标分即胜利，可进入下一关 |
| **2.6** | 失败判定与重试 | 步数用尽且未达目标：进入失败。显示失败 UI（文案 + 重试按钮），点击重试调用 `startLevel(currentLevelId)` 重新开始本关。 | 步数用尽未达标则失败，可重试本关 |
| **2.7** | 游戏内 HUD：步数与分数 | 在 `render()` 中于棋盘上方或侧边绘制当前 `movesLeft` 与 `score`（文字或数字），使用 `ctx.fillText`，样式与布局与现有风格一致。 | 游戏中实时看到剩余步数与当前分数 |
| **2.8** | 准备多关数据并自测 | 至少准备 3～5 关配置（不同 moves、targetScore），验证过关、失败、下一关、重试流程在微信开发者工具与真机均正常。 | 多关可连续玩，胜负与重试/下一关正确 |

**依赖关系简述**：2.1 → 2.2 → 2.3 → 2.4 → 2.7 → 2.5 → 2.6 → 2.8。

---

## 阶段三：关卡目标与障碍

**目标**：像消消乐/梦幻花园那样，每关有「目标」而非仅分数，并加入障碍物。

1. **目标类型（先实现 1–2 种）**
  - **收集目标**：例如「收集 20 个红色宝石」—— 消除红色时计数，达到即完成该目标。
  - **分数目标**：保留阶段二，作为可选目标之一。
  - 关卡配置中声明：`goals: [{ type: "collect", color: 1, amount: 20 }, { type: "score", value: 1000 }]`，全部达成即过关。
2. **障碍物（初版）**
  - **不可消除的格子**：某些格子在配置中标记为「墙」，不参与交换、不被消除。
  - **需要多次打击的障碍**：如「冰块」覆盖在格子上，每次该格被参与消除时扣 1 血，血量为 0 时消失；或「锁链」绑定某格，消除 N 次后解开。
  - 先做 1 种（如墙或单层冰块），数据驱动：在关卡 JSON 里标出障碍位置与类型。
3. **棋盘布局**
  - 支持非矩形：如六边形格、或矩形中挖空（某些格不存在），用「是否存在」标记即可。
  - 仍从「矩形+墙」开始，再扩展挖空。

**交付物**：关卡有明确「收集/分数」目标，带障碍物与基础布局变化，过关条件清晰。

### 阶段三任务拆分（微信小游戏）

按实现顺序拆分为可执行任务，与当前 [game.js](game.js) 的关卡配置、网格与胜负判定衔接。

| 序号 | 任务 | 说明 | 验收 |
|------|------|------|------|
| **3.1** | 关卡配置扩展 goals | 在关卡配置中增加 `goals` 数组，每项 `{ type, ... }`。支持 `type: "score", value: N`（分数目标）与 `type: "collect", color: 0~4, amount: N`（收集某颜色宝石数量）。`getLevelConfig` 返回的配置包含 `goals`，若无则默认仅分数目标（兼容阶段二）。 | 能根据关卡 ID 取到 goals 列表 |
| **3.2** | 收集进度与消除时累加 | 增加 `goalProgress`（如 `{ collect_0: 0, collect_1: 0, ... }` 或数组），在消除阶段（`removeMatches` 或消除动画结束处）按本次消除的格子类型累加对应收集计数。分数目标沿用阶段二 `score >= goal.value`。 | 消除某颜色后该颜色收集数正确增加 |
| **3.3** | 过关条件改为「全部目标达成」 | 胜利判定：遍历当前关 `goals`，分数目标看 `score >= value`，收集目标看对应进度 `>= amount`；全部满足才 `overlay = 'win'`，否则步数用尽仍为失败。 | 多目标时须全部达成才过关 |
| **3.4** | HUD 展示目标与进度 | 在 `render()` 的 HUD 区域绘制当前关目标：分数目标显示「分数: score / value」，收集目标显示「红色: 已收集数 / 目标数」等（可用颜色名或色块区分）。 | 游戏中能看清每个目标的进度 |
| **3.5** | 网格支持「墙」格 | 网格从「每格为类型 0~4 或 -1」扩展为支持「墙」：用常量表示墙（如 -2），或单独 `wallGrid[r][c]` 布尔。`initGrid`/`initGridFromData` 时根据关卡配置（如 `walls: [[r,c], ...]`）写入墙。墙格不参与交换、不参与三连检测、不被消除、不参与下落与填充。 | 墙格不可交换、不可消除，棋盘可含墙 |
| **3.6** | 交换与相邻判定排除墙 | 在 `isAdjacent` 或交换前判断：若 (r1,c1) 或 (r2,c2) 为墙，则不允许交换。触摸选格时墙格不可选（或选墙则忽略）。 | 无法与墙交换，墙不参与操作 |
| **3.7** | 下落与填充跳过墙格 | `drop()`：每列中墙格位置保持不变，仅非墙格下落；空位（非墙且 -1）仅在有墙时仍按列下落逻辑，不向墙格填块。`refill()`：只对非墙且为空的格子填充随机类型。 | 下落与填充后墙格位置与状态不变 |
| **3.8** | 障碍物（可选）单层冰块 | 若做「冰块」：格子可有 `iceHp`（如 1），消除时若该格在匹配内则 `iceHp--`，为 0 时变为普通空位并参与下落/填充。关卡配置如 `ice: [[r,c,hp], ...]`。可与 3.5 同数据结构扩展（如 `grid[r][c]` 为类型，另用 `obstacle[r][c]` 存墙/冰块等）。先做一种即可。 | 冰块被消除一次扣血，血量为 0 后消失（可选） |
| **3.9** | 关卡配置与自测 | 至少 2~3 关带 `goals`（含收集+分数），1~2 关带 `walls`（或 `ice`），验证过关条件、墙格表现、收集进度在工具与真机正常。 | 多关含目标与障碍，行为符合预期 |

**依赖关系与建议顺序**

- **3.1** 为数据基础，最先做。
- **3.2**、**3.3** 依赖 3.1，且 3.3 依赖 3.2 的进度累加。
- **3.4** 依赖 3.1、3.2，用于展示。
- **3.5** 与 3.1 可并行或稍后，为障碍数据与网格扩展。
- **3.6**、**3.7** 依赖 3.5，保证墙参与规则正确。
- **3.8** 为可选，依赖 3.5 的障碍扩展方式。
- **3.9** 为收尾自测。

建议实现顺序：**3.1 → 3.2 → 3.3 → 3.4 → 3.5 → 3.6 → 3.7 → 3.8（可选）→ 3.9**。

---

## 阶段四：特效与反馈

**目标**：消除有动画、有音效，有基础「特殊块」提升爽感。

1. **动画**
  - **交换**：两格位置平滑移动（插值）。
  - **消除**：消除前短暂高亮或缩放，然后消失（淡出或粒子）。
  - **下落**：格子按列下落，带缓动（如 ease-out）。
  - **填充**：新块从列顶「掉入」或淡入。
2. **音效与音乐**
  - 交换、消除、连消、过关、失败各一音效；背景音乐可选。
  - 微信小游戏使用 **`wx.createInnerAudioContext()`** 播放音效与背景音乐，注意小游戏音频规范（如用户交互后首次播放限制）。
3. **特殊块（初版）**
  - **四连/L/T 形**：生成「直线消除器」（横或竖消一整行/列）。
  - **五连或两个三连相交**：生成「范围爆炸」（3×3 或十字）。
  - 规则：在消除判定时识别这些形状，在对应中心格生成特殊块；下次该格被「触发」（参与任意消除）时执行效果。
  - 先做「直线消除」与「3×3 爆炸」两种，数据上用「类型 6、7」或 `special: "line", "bomb"` 标记。

**交付物**：玩起来有动效与音效，存在 1–2 种特殊块，连消反馈明显。

---

## 阶段五：关卡池与 meta 进度

**目标**：关卡列表、星级、简单 meta 进度；统一数据存储方案；提供游戏数值配置工具（或导入配置表），为后续「家园/花园」打基础。

1. **数据存储方案**
  - 约定本地持久化的 key、结构与用途，使用 **`wx.getStorageSync` / `wx.setStorageSync`**（替代 localStorage）。
  - **game_save**：`{ version, maxUnlockedLevel, stars: { [levelId]: 0|1|2|3 } }`，可选 `hearts`、`lastHeartTime`；启动时读，过关/失败时写。
  - **game_settings**（可选）：音效/音乐开关等，启动时读、设置变更时写。
  - 读写封装：`loadSave()` 读并补默认值，`saveSave(data)` 写；缺档或异常时返回默认 `maxUnlockedLevel: 1, stars: {}`。
2. **游戏数值配置工具（或导入配置表）**
  - **方式 A（推荐先做）**：配置表导入工具。约定关卡配置表格式（CSV 或 Excel 导出 JSON），列含 id、moves、targetScore、star2Score、star3Score、goals、walls、ice 等；提供脚本（如 `tools/import-levels.js`）读取并校验，输出 `data/levels.json`。游戏从包内加载该 JSON（或构建时打入 levels.js），不再仅依赖 game.js 内联 LEVELS。
  - **方式 B（可选）**：简易数值配置界面，本地编辑关卡列表并保存为 JSON，与 A 共用同一 schema。
3. **关卡列表与选择**
  - 关卡选择界面：地图或列表，显示已解锁关卡、当前关卡、已获星级；过关后解锁下一关；可加「钥匙」或「体力」限制（如每日 5 颗心，失败扣 1）。
4. **星级评价**
  - 根据分数或剩余步数给 1–3 星；关卡配置里定义星级阈值（如 star2Score、star3Score）；在关卡选择界面与胜利面板显示每关/本次星级。
5. **存档与进度**
  - 过关时更新 maxUnlockedLevel、本关 stars（取历史最佳），并调用 saveSave；新用户无档时表现与默认一致；后续扩展字段时通过 version 或缺省兼容。

**交付物**：统一存储方案与读写、配置表导入工具（或等效）、关卡地图/列表、星级、本地进度存档，可选体力/钥匙。

### 阶段五任务拆分（微信小游戏）

按实现顺序拆分为可执行任务，与当前 game.js 的关卡配置、胜负判定衔接。

| 序号 | 任务 | 说明 | 验收 |
|------|------|------|------|
| **5.1** | 数据存储方案与读写封装 | 约定 key：`game_save`（必做）、`game_settings`（可选）。`game_save` 结构：`{ version: 1, maxUnlockedLevel, stars: {} }`。实现 `loadSave()`（wx.getStorageSync 读、异常/缺档返回默认）、`saveSave(data)`（wx.setStorageSync 写）。游戏启动时调用 loadSave() 得到全局 saveData。 | 能安全读写 game_save，无档时默认 maxUnlockedLevel: 1、stars: {} |
| **5.2** | 关卡配置扩展星级阈值 | 在关卡配置中增加 star2Score、star3Score（达成分数即 2 星/3 星）；无则用默认（如 2 星=目标分×1.2，3 星=目标分×1.5）。getLevelConfig 返回的配置包含或可推导星级条件。 | 能根据关卡 ID 取到星级阈值或默认规则 |
| **5.3** | 配置表格式约定与导入脚本 | 约定关卡配置表格式（CSV 列或 JSON 结构），与现有 LEVELS 数组一致。在项目内提供 tools/import-levels.js（或等价脚本）：读取 CSV/JSON，校验必填字段，输出 data/levels.json。 | 修改表后运行脚本可得到合法 data/levels.json |
| **5.4** | 游戏从包内加载关卡配置 | 支持从 data/levels.json 加载关卡列表（如 wx.getFileSystemManager 或构建时复制为 js）；若文件不存在则回退到 game.js 内联 LEVELS。getLevelConfig(levelId) 统一从同一数据源取配置。 | 游戏使用 data/levels.json 或内联数据，行为一致 |
| **5.5** | 过关时计算星级并更新存档 | 在判定胜利处根据 score（及可选 movesLeft）与当前关星级阈值计算本局 1～3 星；更新 saveData.maxUnlockedLevel（若有下一关）、saveData.stars[currentLevelId]（取历史最佳）；调用 saveSave(saveData)。失败不更新星级。 | 过关后存档正确，重启后进度与星级保留 |
| **5.6** | 关卡选择界面（列表或地图） | 引入 gameScene = 'map' \| 'play'。main() 启动后进入 map，绘制关卡列表/地图；已解锁（levelId <= saveData.maxUnlockedLevel）可点击进入 startLevel(id) 并切到 play。胜负面板增加「返回地图」按钮，点击回到 map。 | 启动进关卡选择，能选关进入、返回地图 |
| **5.7** | 星级在关卡选择与胜利面板展示 | 关卡选择界面每关显示 saveData.stars[levelId]（0～3 星）；胜利面板显示本局获得的星级（lastEarnedStars）。 | 地图与胜利时星级显示正确 |
| **5.8** | 体力/钥匙（可选） | 若做：存档增加 hearts、lastHeartTime；进入关卡前检查体力，失败扣 1 并写档；恢复规则（如每日回满或定时恢复）。不做则跳过。 | 若实现则体力扣减与恢复符合设计 |
| **5.9** | 自测与真机验证 | 验证：改配置表→导入→游戏加载新数值；过关/失败→关游戏再开→进度与星级持久化；关卡选择解锁与星级、返回地图、下一关流程在工具与真机正常。 | 配置工具与存档、关卡池在真机均正常 |

**依赖关系简述**：5.1（存储）→ 5.2（星级阈值）→ 5.5（过关写档）；5.1 → 5.6（关卡选择读档）；5.3 → 5.4（导入产出被游戏加载）；5.2、5.5 → 5.7（星级展示）。建议顺序：**5.1 → 5.2 → 5.3 → 5.4 → 5.5 → 5.6 → 5.7 → 5.8（可选）→ 5.9**。

---

## 阶段六：类梦幻家园/花园的 meta 层（已纳入计划，稍后安排继续讨论）

**目标**：三消驱动「剧情 + 装饰」的成长感，而非只闯关。

1. **资源与货币**
  - 过关获得「星星」或「金币」；用于购买装饰、推进剧情。
  - 部分关卡要求「先获得某道具」或「达到某装饰进度」才解锁。
2. **家园/花园场景**
  - 一个独立场景：可放置的家具/植物/建筑，用 2D 贴图 + 拖拽放置。
  - 装饰项用配置表：id、名称、所需金币/星星、解锁关卡、摆放区域。
3. **简单剧情**
  - 线性剧情：每过 N 关或完成某装饰，解锁一段对话/过场。
  - 文本 + 立绘或背景图即可；数据用 JSON 定义节点与跳转。
4. **任务与每日**
  - 每日任务：如「完成 3 关」「产生 5 次四连」；完成后给额外货币。
  - 增加重复可玩性与短期目标。

**交付物**：三消 + 可装饰场景 + 简单剧情与任务，整体体验接近「过关拿资源 → 装修/看剧情」的循环。

*阶段六已合并进本开发计划，具体任务拆分与实现顺序待后续讨论确定。*

---

## 迭代节奏建议

| 阶段  | 建议周期  | 可演示内容       |
| --- | ----- | ----------- |
| 一   | 1–2 周 | 能无限玩的基础三消   |
| 二   | 约 1 周 | 多关、步数、分数与胜负 |
| 三   | 1–2 周 | 收集目标与障碍物    |
| 四   | 1–2 周 | 动画、音效、特殊块   |
| 五   | 约 1 周 | 关卡地图、星级、存档  |
| 六   | 按需    | 装饰与剧情 meta  |

每阶段结束都保留一个可运行、可试玩的版本，再进入下一阶段；优先保证阶段一稳定可玩，再扩展规则与表现。

---

## 已确认与待定

- **平台**：已确定为**微信小游戏**，阶段一至五均按小游戏项目结构（`game.js`、`game.json`、Canvas 与 `wx.*` API）实现。
- **阶段六**：类梦幻家园/花园的 meta 层已纳入本计划（见上文阶段六章节），具体任务拆分与排期稍后安排继续讨论。
- 若需开工阶段一，可按微信小游戏规范拆出任务清单（入口、画布创建、触摸坐标、无 DOM 的渲染循环等）。
